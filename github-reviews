#!/usr/bin/bash
set -o nounset
set -o errtrace
set -o pipefail
function CATCH_ERROR { # {{{
    local __LEC=$? __i __j
    set +x
    echo "Traceback (most recent call last):" >&2
    for ((__i = ${#FUNCNAME[@]} - 1; __i >= 0; --__i)); do
        printf '  File %q line %s in %q\n' >&2 \
            "${BASH_SOURCE[__i]}" \
            "${BASH_LINENO[__i]}" \
            "${FUNCNAME[__i]}"
        if ((BASH_LINENO[__i])) && [ -f "${BASH_SOURCE[__i]}" ]; then
            for ((__j = 0; __j < BASH_LINENO[__i]; ++__j)); do
                read -r REPLY
            done < "${BASH_SOURCE[__i]}"
            printf '    %s\n' "$REPLY" >&2
        fi
    done
    echo "Error: [ExitCode: ${__LEC}]" >&2
    exit "${__LEC}"
}
trap CATCH_ERROR ERR # }}}

req_opts=(
    --retry-all-errors
    --retry 4
    --connect-timeout 15
    -H "Accept: application/vnd.github+json"
    -H "X-GitHub-Api-Version: 2022-11-28"
)
args=()
repo=''
OPTIND=1
while case "${!OPTIND---}" in
    -*?)false;;
    *)  args+=("${!OPTIND}"); ((++OPTIND)); continue
esac || getopts haR: opt; do case "$opt" in
    a)
        req_opts+=(-H "Authorization: Bearer ${GH_TOKEN:=$(
            hash grep tail
            grep -oP 'oauth_token: *\K.*' ~/.config/gh/hosts.yml | tail -n1
        )}")
        ;;
    R) repo=$OPTARG;;
    h)
        printf 'Usage: %q [Options] [number]\n' "${0##*/}"
        echo 'show github pull request reviews'
        echo
        printf '%s\n' \
            'Options:' \
            '    -a                 try using GH_TOKEN' \
            '    -h                 show help' \
            && exit
        ;;
    :|\?)
        ((--OPTIND <= 0)) && OPTIND=1
        printf '%q: parse args failed, near by %q\n' "$0" "${!OPTIND}" >&2
        exit 2
esac done
set -- "${args[@]}" "${@:OPTIND}"

if [ $# -gt 1 ]; then
    printf '%q: unexpected arg %q\n' "$0" "$2" >&2
    exit 2
fi

shopt -s extglob
repo=${repo##?(http?(s)://)?(www.)github.com/}
repo=${repo:-$(gh repo set-default -v || exit)}
id=${1:-$(gh pr view --json number | jq .number || exit)}

function fail { # {{{
    echo "fail: ${*@Q}" >&2
    return 1
} # }}}

hash gh curl jq

api=(https://api.github.com/repos/$repo/{issues/$id/comments,pulls/$id{,/comments,/reviews}})

printf 'api: %s\n' "${api[@]@Q}"

curl --no-progress-meter "${req_opts[@]}" -- "${api[@]}" |
jq -nr \
'
{
  "+1":       "ðŸ‘",
  "-1":       "ðŸ‘Ž",
  "laugh":    "ðŸ˜„",
  "hooray":   "ðŸŽ‰",
  "confused": "â“",
  "heart":    "â¤ï¸",
  "rocket":   "ðŸš€",
  "eyes":     "ðŸ‘€",
} as $reactions |

def fi($n): tostring | .+" "*($n-length);
def csim(seq): [seq]|"\u001b[\(join(";"))m";
def csim: csim(empty);
def title: .[:1]+(.[1:]|ascii_downcase);
def bool($x): $x | length | . != 0 and . != null;
def rtrim: sub("\\s+$"; "");
def clean_csi: gsub("\u001b\\[(\\d+(;\\d+)*)m"; "");
def differ:
  if startswith("+") then
    csim(32)+.+csim
  elif startswith("-") then
    csim(31)+.+csim
  elif startswith("@@") then
    csim(36)+.+csim
  elif startswith("%") then
    csim(33)+.+csim
  end
  ;
def bodyer(lines):
  foreach lines as $line ({code:false};
    .cur = ($line | test("^ *```[^`]*$")) | if .cur then .code |= not end;
    if .code or .cur then
      [csim(2,48,5,236)+"\u001b[K"+$line+csim(49,22)]
    elif $line | startswith("> ") or .==">" then
      [csim(38,5,251)+"â”‚ "+$line[2:]+csim, true]
    else
      [$line, true]
    end
  ) | . as [$line, $render] | $line |
  if $render then
    # markdown inline
    . + "\u001b[K"
    | gsub("(?<x>(?<!\\*)\\*[^* ](\\\\|[^`])*?(?<![* ])\\*)"; csim(3)+.x+csim(23))
    | gsub("(?<x>(?<!\\*)\\*\\*[^* ](\\\\|[^`])*?(?<![* ])\\*\\*)"; csim(1)+.x+csim(22))
    | gsub("(?<x>(?<!\\*)\\*\\*\\*[^* ](\\\\|[^`])*?(?<![* ])\\*\\*\\*)"; csim(1,3)+.x+csim(23,22))
    | gsub("(?<x>(?<!~)~~[^~ ](\\\\|[^`])*?(?<![~ ])~~)"; csim(9)+.x+csim(29))
    | gsub("(?<!`)(?<q>`+)(?<x>( *)[^ `](?:(?!\\3\\1).)*\\3)\\1"; csim(2,8,48,5,236)+.q+csim(28)+(.x|clean_csi)+csim(8)+.q+csim(28,49,22))
  end
  ;
def diff_title:
  first(reverse[] | select(test("^.\\S.{3}"))[1:75])
  ;
def expected($ty):
  if type != $ty then
    debug | error("unexpected input type \(type), expected a \($ty)")
  end
  ;
def pull_body_pack:
  if has("body")? // false then
    if has("title") then .body = .title+"\n\n"+.body end |
    if .merged then .state = "merged" end |
    [.]
  end;
def patch_formatter:
  expected("array") |
  if length > 50 then
    .[4:length-20] |= ["% Folded \(length) lines %\(" "+diff_title // "")"]
  elif length == 0 or . == [""] then
    ["% No patch provided"]
  end
  ;
def elap:
  [
    (now, fromdate)
    | strftime("%s")
    | tonumber
  ]
  | first-last
  | [
      ., (
        ./60 | ., (
          ./60 | ., (
            ./24 | ., (
              ./30.4375 | ., (
                ./12)))))
      | floor
    ]
  | [" seconds", " minutes", "h", "d", " months", " years"] as $label
  | last(to_entries[]
    | [.value, $label[.key]]
    | select(first > 1)
    | join("")
    ) // ""
  ;
def clean:
  if type == "string" then
    rtrim
  end
  ;
def association:
  if .author_association and .author_association != "NONE" then
    " (\(.author_association|title))"
  else
    ""
  end;
def state:
  .state | if . then
    " "+(ascii_downcase
      | if endswith("requested") then
        csim(31)+.+csim(39)
      elif endswith("approved") then
        csim(32)+.+csim(39)
      end)
  else
    ""
  end
  ;
def reactions:
  [.reactions
  | values
  | to_entries[]
  | "\(.value | select(. != 0)) \($reactions[.key] | values)"
  ] | join(" ") | select(bool(.))
  ;
"\u0000topLevel" as $top |
reduce (inputs | pull_body_pack | expected("array"))[] as $review ({};
  .[$review.diff_hunk // $top] += [$review | {
    user: .user.login,
    body,
    created_at: (.created_at // .submitted_at // "9999-12-31T23:59:59Z"),
    updated_at,
    html_url,
    author_association,
    path,
    state,
    reactions,
  }]
)
| .[][].body |= clean
| to_entries
| map(if .key == $top then .value = (.value[] | select(.state != "COMMENTED" or bool(.body)) | [.]) end)
| sort_by(.value[0].created_at | fromdate)[]
|
( (.value[0].path | values | "", .)
, (.key | select(. != $top) | [splits("\n")] | patch_formatter[] | "â”‚ "+differ)
, (.value[]
  | (if .updated_at and .updated_at != .created_at then
      " update at \(.updated_at|elap)" else ""
    end) as $update
  | "\n"+csim(1)+("\(.user)\(association)\(state)"|fi(50))+csim+" â€¢ \((.created_at|elap)+$update)"
  , reactions
  , ""
  , if bool(.body) then
      "  "+bodyer(.body | splits(" *\r?\n"))
    else
      "  "+csim(90)+"No body provided"+csim
    end
  , ""
  , csim(90)+"View the full review: "+.html_url+csim
  )
, (select(.value[0].path != null) | "", "â”€"*70)
)
'
