#!/usr/bin/bash
set -o nounset
set -o errtrace
set -o pipefail
function CATCH_ERROR { # {{{
    local __LEC=$? __i __j
    set +x
    echo "Traceback (most recent call last):" >&2
    for ((__i = ${#FUNCNAME[@]} - 1; __i >= 0; --__i)); do
        printf '  File %q line %s in %q\n' >&2 \
            "${BASH_SOURCE[__i]}" \
            "${BASH_LINENO[__i]}" \
            "${FUNCNAME[__i]}"
        if ((BASH_LINENO[__i])) && [ -f "${BASH_SOURCE[__i]}" ]; then
            for ((__j = 0; __j < BASH_LINENO[__i]; ++__j)); do
                read -r REPLY
            done < "${BASH_SOURCE[__i]}"
            printf '    %s\n' "$REPLY" >&2
        fi
    done
    echo "Error: [ExitCode: ${__LEC}]" >&2
    exit "${__LEC}"
}
trap CATCH_ERROR ERR # }}}

req_opts=(
    --retry 4
    -H "Accept: application/vnd.github+json"
    -H "X-GitHub-Api-Version: 2022-11-28"
)
args=()
OPTIND=1
while case "${!OPTIND---}" in
    -*?)false;;
    *)  args+=("${!OPTIND}"); ((++OPTIND)); continue
esac || getopts ha opt; do case "$opt" in
    a)
        req_opts+=(-H "Authorization: Bearer ${GH_TOKEN:=$(
            hash grep tail
            grep -oP 'oauth_token: *\K.*' ~/.config/gh/hosts.yml | tail -n1
        )}")
        ;;
    h)
        printf 'Usage: %q [Options]\n' "${0##*/}"
        echo 'show github pull request reviews'
        echo
        printf '%s\n' \
            'Options:' \
            '    -a                 try using GH_TOKEN' \
            '    -h                 show help' \
            && exit
        ;;
    :|\?)
        ((--OPTIND <= 0)) && OPTIND=1
        printf '%q: parse args failed, near by %q\n' "$0" "${!OPTIND}" >&2
        exit 2
esac done
set -- "${args[@]}" "${@:OPTIND}"

function fail { # {{{
    echo "fail: ${*@Q}" >&2
    return 1
} # }}}

hash gh curl jq

url=$(gh pr view --json url -- "$@" | jq -r .url || exit)
[[ $url = */pull/* ]] || fail "$url"
[[ $url = https://github.com/* ]] || fail "$url"
content=${url#https://github.com/}
id=${content##*/}
repo=${content%/pull/$id}
api=(https://api.github.com/repos/$repo/{issues/$id/comments,pulls/$id/{comments,reviews}})

echo "api: ${api[*]@Q}"

curl --no-progress-meter "${req_opts[@]}" -- "${api[@]}" |
jq -nr \
'
{
  "+1":       "👍",
  "-1":       "👎",
  "laugh":    "😄",
  "hooray":   "🎉",
  "confused": "❓",
  "heart":    "❤️",
  "rocket":   "🚀",
  "eyes":     "👀",
} as $reactions |

def fi($n): tostring | .+" "*($n-length);
def csim(seq): [seq]|"\u001b[\(join(";"))m";
def csim: csim(empty);
def title: .[:1]+(.[1:]|ascii_downcase);
def bool($x): $x | length | . != 0 and . != null;
def differ:
  if startswith("+") then
    csim(32)+.+csim
  elif startswith("-") then
    csim(31)+.+csim
  elif startswith("@@") then
    csim(36)+.+csim
  elif startswith("%") then
    csim(33)+.+csim
  end
  ;
def bodyer:
  if startswith("> ") then
    csim(38,5,251)+"│ "+.[2:]+csim
  end
  ;
def expected($ty):
  if type != $ty then
    debug | error("unexpected input type \(type), expected a \($ty)")
  end
  ;
def fold_too_long:
  expected("array") |
  if length > 50 then
    .[20:length-20] |= ["% Folded \(length) lines"]
  end
  ;
def elap:
  [
    (now, fromdate)
    | strftime("%s")
    | tonumber
  ]
  | first-last
  | [
      ., (
        ./60 | ., (
          ./60 | ., (
            ./24 | ., (
              ./30.4375 | ., (
                ./12)))))
      | floor
    ]
  | [" seconds", " minutes", "h", "d", " months", " years"] as $label
  | last(to_entries[]
    | [.value, $label[.key]]
    | select(first > 1)
    | join("")
  )
  ;
def clean:
  if type == "string" then
    rtrim
  end
  ;
def association:
  if .author_association and .author_association != "NONE" then
    " (\(.author_association|title))"
  else
    ""
  end;
def state:
  .state | if . then
    " "+ascii_downcase
  else
    ""
  end
  ;
def reactions:
  [.reactions
  | values
  | to_entries[]
  | "\(.value | select(. != 0)) \($reactions[.key] | values)"
  ] | join(" ") | select(bool(.))
  ;
"\u0000topLevel" as $top |
reduce (inputs | expected("array"))[] as $review ({};
  .[$review.diff_hunk // $top] += [$review | {
    user: .user.login,
    body,
    created_at: .created_at // .submitted_at,
    updated_at,
    html_url,
    author_association,
    path,
    state,
    reactions,
  }]
)
| .[][].body |= clean
| to_entries
| map(if .key == $top then .value = (.value[] | select(.state != "COMMENTED" or bool(.body)) | [.]) end)
| sort_by(.value[0].created_at | fromdate)[]
|
( (.value[0].path | values | "", .)
, (.key | select(. != $top) | [splits("\n")] | fold_too_long[] | "│ "+differ)
, (.value[]
  | (if .updated_at and .updated_at != .created_at then
      " update at \(.updated_at|elap)" else ""
    end) as $update
  | "\n"+csim(1)+("\(.user)\(association)\(state)"|fi(50))+csim+" • \((.created_at|elap)+$update)"
  , reactions
  , ""
  , if bool(.body) then
      .body | splits("\n") | "  "+bodyer
    else
      "  "+csim(90)+"No body provided"+csim
    end
  , ""
  , csim(90)+"View the full review: "+.html_url+csim
  )
, (select(.value[0].path != null) | "", "─"*70)
)
'
