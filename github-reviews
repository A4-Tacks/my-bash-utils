#!/usr/bin/bash
set -o nounset
set -o errtrace
set -o pipefail
function CATCH_ERROR { # {{{
    local __LEC=$? __i __j
    set +x
    echo "Traceback (most recent call last):" >&2
    for ((__i = ${#FUNCNAME[@]} - 1; __i >= 0; --__i)); do
        printf '  File %q line %s in %q\n' >&2 \
            "${BASH_SOURCE[__i]}" \
            "${BASH_LINENO[__i]}" \
            "${FUNCNAME[__i]}"
        if ((BASH_LINENO[__i])) && [ -f "${BASH_SOURCE[__i]}" ]; then
            for ((__j = 0; __j < BASH_LINENO[__i]; ++__j)); do
                read -r REPLY
            done < "${BASH_SOURCE[__i]}"
            printf '    %s\n' "$REPLY" >&2
        fi
    done
    echo "Error: [ExitCode: ${__LEC}]" >&2
    exit "${__LEC}"
}
trap CATCH_ERROR ERR # }}}

req_opts=(
    -H "Accept: application/vnd.github+json"
    -H "X-GitHub-Api-Version: 2022-11-28"
)
args=()
OPTIND=1
while case "${!OPTIND---}" in
    -*?)false;;
    *)  args+=("${!OPTIND}"); ((++OPTIND)); continue
esac || getopts ha opt; do case "$opt" in
    a)
        req_opts+=(-H "Authorization: Bearer ${GH_TOKEN:=$(
            hash grep tail
            grep -oP 'oauth_token: *\K.*' ~/.config/gh/hosts.yml | tail -n1
        )}")
        ;;
    h)
        printf 'Usage: %q [Options]\n' "${0##*/}"
        echo 'show github pull request reviews'
        echo
        printf '%s\n' \
            'Options:' \
            '    -a                 try using GH_TOKEN' \
            '    -h                 show help' \
            && exit
        ;;
    :|\?)
        ((--OPTIND <= 0)) && OPTIND=1
        printf '%q: parse args failed, near by %q\n' "$0" "${!OPTIND}" >&2
        exit 2
esac done
set -- "${args[@]}" "${@:OPTIND}"

function fail { # {{{
    echo "fail: ${*@Q}" >&2
    return 1
} # }}}

hash gh curl jq

url=$(gh pr view --json url -- "$@" | jq -r .url || exit)
[[ $url = */pull/* ]] || fail "$url"
[[ $url = https://github.com/* ]] || fail "$url"
content=${url#https://github.com/}
id=${content##*/}
repo=${content%/pull/$id}
api=(https://api.github.com/repos/$repo/{issues/$id/comments,pulls/$id/{comments,reviews}})

echo "api: ${api[*]@Q}"

curl --no-progress-meter "${req_opts[@]}" -- "${api[@]}" |
jq -nr \
'
def fi($n): tostring | .+" "*($n-length);
def csim(seq): [seq]|"\u001b[\(join(";"))m";
def csim: csim(empty);
def title: .[:1]+(.[1:]|ascii_downcase);
def expected($ty):
  if type != $ty then
    debug | error("unexpected input type \(type), expected a \($ty)")
  end
  ;
def elap:
  [
    (now | strftime("%y %m %d %H")),(fromdate | strftime("%y %m %d %H"))
    | split(" ")[]
    | tonumber
  ] as [$ny, $nm, $nd, $nh, $y, $m, $d, $h] |
  first(
    [$ny-$y, " years"],
    [$nm-$m, "m"],
    [$nd-$d, "d"],
    [$nh-$h, "h"]
    | select(first > 0)
  ) | join("")
  ;
def association:
  if .author_association and .author_association != "NONE" then
    " (\(.author_association|title))"
  else
    ""
  end;
def state:
  .state | if . then
    " "+ascii_downcase
  else
    ""
  end
  ;
reduce (inputs | expected("array"))[] as $review ({};
  .[$review.diff_hunk // ""] += [$review | {
    user: .user.login,
    body,
    created_at: .created_at // .submitted_at,
    updated_at,
    html_url,
    author_association,
    path,
    state,
  }]
)
| to_entries
| map(if .key == "" then .value = (.value[] | select(.state != "COMMENTED") | [.]) end)
| sort_by(.value[0].created_at | fromdate)[]
|
( (.value[0].path | values)
, (.key | select(length != 0) | "│ "+splits("\n"))
, (.value[]
  | (if .updated_at and .updated_at != .created_at then
      " update at \(.updated_at|elap)" else ""
    end) as $update
  | "\n"+csim(1)+("\(.user)\(association)\(state)"|fi(50))+csim+" • \((.created_at|elap)+$update)"
  , ""
  , if .body | length != 0 then
      .body | "  "+splits("\n")
    else
      "  "+csim(90)+"No body provided"+csim
    end
  , ""
  , csim(90)+"View the full review: "+.html_url+csim
  )
, (select(.value[0].path != null) | "", "─"*70)
)
'
