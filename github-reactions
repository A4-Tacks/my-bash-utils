#!/usr/bin/bash
set -o nounset
set -o errtrace
set -o pipefail
function CATCH_ERROR { # {{{
    local __LEC=$? __i __j
    set +x
    echo "Traceback (most recent call last):" >&2
    for ((__i = ${#FUNCNAME[@]} - 1; __i >= 0; --__i)); do
        printf '  File %q line %s in %q\n' >&2 \
            "${BASH_SOURCE[__i]}" \
            "${BASH_LINENO[__i]}" \
            "${FUNCNAME[__i]}"
        if ((BASH_LINENO[__i])) && [ -f "${BASH_SOURCE[__i]}" ]; then
            for ((__j = 0; __j < BASH_LINENO[__i]; ++__j)); do
                read -r REPLY
            done < "${BASH_SOURCE[__i]}"
            printf '    %s\n' "$REPLY" >&2
        fi
    done
    echo "Error: [ExitCode: ${__LEC}]" >&2
    exit "${__LEC}"
}
trap CATCH_ERROR ERR # }}}

send=''

args=()
OPTIND=1
while case "${!OPTIND---}" in
    -*?)false;;
    *)  args+=("${!OPTIND}"); ((++OPTIND)); continue
esac || getopts hs opt; do case "$opt" in
    h)
        printf 'Usage: %q [Options] <comment_url>\n' "${0##*/}"
        echo
        printf '%s\n' \
            'Options:' \
            '    -s                 send mode' \
            '    -h                 show help' \
            && exit
        ;;
    s) send=1;;
    :|\?)
        ((--OPTIND <= 0)) && OPTIND=1
        printf '%q: parse args failed, near by %q\n' "$0" "${!OPTIND}" >&2
        exit 2
esac done
set -- "${args[@]}" "${@:OPTIND}"

if [ $# -eq 0 ]; then
    printf '%q: expected a arg\n' "$0" >&2
    exit 2
fi
if [ $# -ne 1 ]; then
    printf '%q: unexpected arg %q\n' "$0" "$2" >&2
    exit 2
fi

# shellcheck disable=2089
emoji='{
  "+1":       "üëç",
  "-1":       "üëé",
  "laugh":    "üòÑ",
  "hooray":   "üéâ",
  "confused": "‚ùì",
  "heart":    "‚ù§Ô∏è",
  "rocket":   "üöÄ",
  "eyes":     "üëÄ",
}'

api=$(jq -Rrs <<< "$1" '
sub("\\s*$"; "") |
capture("^\\s*
  (https?://)?github\\.com/
  (?<owner>[^/]+)/
  (?<repo>[^/]+)/
  (pull|issues)/
  (?<number>[^#/]+)
  (
      \\#(?<kind>discussion_r|issuecomment-|pullrequestreview-)
      (?<id>\\d+)
  )?
  \\s*$";
"x") // error("Invalid comment url: \(@sh)")
| ((select(.id) | "/comments") // "") as $com
| ((select(.kind == "discussion_r") | "pulls") // "issues") as $kind
| "/repos/\(.owner)/\(.repo)/\($kind+$com)/\(.id // .number)/reactions"
') || exit

echo "${api@A}" >&2

if [ -n "$send" ]; then
    PS3="select emoji> "
    eval "$(jq -nr "$emoji"'|"select _ in \(join(" ")); do case $REPLY in",
    "    \(keys_unsorted|to_entries[]|"(\(.key+1)) REPLY=\(.value|@sh); break;;")",
    "    (*) echo Invalid REPLY;;",
    "esac done"')" || exit

    gh api --method POST \
        -H "Accept: application/vnd.github+json" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        -f "content=$REPLY" \
        "$api" | jq 'select(.node_id and .user.id | not)'
fi

reactions=$(gh api --method GET \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "$api") || exit

jq -r <<< "$reactions" "$emoji"' as $reactions |
def elap:
  [
    (now, fromdate)
    | strftime("%s")
    | tonumber
  ]
  | first-last
  | [
      ., (
        ./60 | ., (
          ./60 | ., (
            ./24 | ., (
              ./30.4375 | ., (
                ./12)))))
      | floor
    ]
  | [" seconds", " minutes", "h", "d", " months", " years"] as $label
  | last(to_entries[]
    | [.value, $label[.key]]
    | select(first > 1)
    | join("")
  )
  | if length == 0 then "now" end
  ;
def g($n): "\u001b[\($n)G";
sort_by(.created_at | fromdate)[]
| .created_at |= elap
| .user |= .login
| "\(.user+g(26)) at \(.created_at+g(41))"+$reactions[.content]+" ("+.content+")"
'
